package scripts.factions.patches

import com.google.common.collect.Sets
import org.starcade.starlight.helper.Events
import org.starcade.starlight.helper.event.filter.EventFilters
import org.starcade.starlight.helper.utils.Players
import groovy.transform.Field
import org.bukkit.Bukkit
import org.bukkit.GameMode
import org.bukkit.Location
import org.bukkit.Material
import org.bukkit.Sound
import org.bukkit.World
import org.bukkit.block.Block
import org.bukkit.block.BlockFace
import org.bukkit.block.Skull
import org.bukkit.block.data.Waterlogged
import org.bukkit.block.data.type.AmethystCluster
import org.bukkit.block.data.type.Bed
import org.bukkit.block.data.type.Campfire
import org.bukkit.block.data.type.Chest
import org.bukkit.block.data.type.EnderChest
import org.bukkit.block.data.type.Farmland
import org.bukkit.block.data.type.Lantern
import org.bukkit.block.data.type.PointedDripstone
import org.bukkit.block.data.type.SeaPickle
import org.bukkit.block.data.type.Sign
import org.bukkit.block.data.type.Slab
import org.bukkit.block.data.type.TrapDoor
import org.bukkit.block.data.type.WallSign
import org.bukkit.command.ConsoleCommandSender
import org.bukkit.entity.EntityType
import org.bukkit.entity.FallingBlock
import org.bukkit.entity.Player
import org.bukkit.event.Event
import org.bukkit.event.EventPriority
import org.bukkit.event.block.Action
import org.bukkit.event.entity.CreatureSpawnEvent
import org.bukkit.event.entity.EntityChangeBlockEvent
import org.bukkit.event.entity.EntityDamageByEntityEvent
import org.bukkit.event.entity.EntityExplodeEvent
import org.bukkit.event.entity.EntityPickupItemEvent
import org.bukkit.event.entity.ItemSpawnEvent
import org.bukkit.event.entity.PlayerDeathEvent
import org.bukkit.event.inventory.ClickType
import org.bukkit.event.inventory.InventoryAction
import org.bukkit.event.inventory.InventoryClickEvent
import org.bukkit.event.inventory.InventoryCloseEvent
import org.bukkit.event.inventory.InventoryOpenEvent
import org.bukkit.event.inventory.InventoryType
import org.bukkit.event.player.PlayerCommandPreprocessEvent
import org.bukkit.event.player.PlayerDropItemEvent
import org.bukkit.event.player.PlayerInteractEvent
import org.bukkit.event.player.PlayerJoinEvent
import org.bukkit.event.player.PlayerMoveEvent
import org.bukkit.event.player.PlayerQuitEvent
import org.bukkit.event.player.PlayerRespawnEvent
import org.bukkit.event.player.PlayerTeleportEvent
import org.bukkit.inventory.EquipmentSlot
import org.bukkit.inventory.Inventory
import org.bukkit.inventory.ItemStack
import scripts.factions.core.faction.FactionUtils
import scripts.factions.core.faction.Factions
import scripts.shared.utils.MovementUtils
import scripts.shared.utils.WorldUtils

import javax.annotation.Nonnull
import java.util.concurrent.TimeUnit

@Field static Set<UUID> permBypassingPlayers = Sets.newHashSet()
@Field static Set<UUID> factionsBypassingPlayers = Sets.newHashSet()
@Field static Set<UUID> anvilUsagePlayers = Sets.newHashSet()

Events.subscribe(PlayerTeleportEvent.class, EventPriority.MONITOR).filter(EventFilters.<PlayerTeleportEvent> ignoreCancelled()).handler { event ->
    if (Patches.exploitMovementLimitations) {
        Player player = event.getPlayer()
        Factions.getMember(player.getUniqueId()).setTeleported(true)
        boolean isCitizensNPC = player.hasMetadata("NPC")
        if (!isCitizensNPC) {
            Location to = event.getTo()
            Location from = event.getFrom()
            if (!MovementUtils.isPlayerSameChunk(from, to)) {
                updateFactionsBypass(player, to)
            }

        }
    }
}
Events.subscribe(PlayerRespawnEvent.class, EventPriority.MONITOR).handler { event ->
    if (Patches.exploitMovementLimitations) {
        Factions.getMember(event.player.getUniqueId()).setTeleported(true)
        if (event.getPlayer().isInsideVehicle()) {
            event.getPlayer().leaveVehicle()
        }

    }
}
Events.subscribe(PlayerDeathEvent.class, EventPriority.HIGHEST).filter(EventFilters.<PlayerDeathEvent> ignoreCancelled()).handler { event ->
    if (Patches.exploitMovementLimitations) {
        if (event.getEntity() instanceof Player) {
            Player player = event.getEntity()
            if (player.isInsideVehicle()) {
                player.leaveVehicle()
            }

        }
    }
}
Events.subscribe(EntityDamageByEntityEvent.class, EventPriority.HIGH).filter(EventFilters.<EntityDamageByEntityEvent> ignoreCancelled()).handler { event ->
    if (Patches.exploitMovementLimitations) {
        if (event.getDamager().isDead()) {
            event.setCancelled(true)
        }

    }
}
Events.subscribe(PlayerCommandPreprocessEvent.class, EventPriority.HIGH).filter(EventFilters.<PlayerCommandPreprocessEvent> ignoreCancelled()).handler { event ->
    if (Patches.exploitMovementLimitations) {
        if (event.getPlayer().isDead()) {
            event.setCancelled(true)
        }

    }
}
Events.subscribe(PlayerJoinEvent.class, EventPriority.HIGH).handler { event ->
    if (Patches.exploitMovementLimitations) {
        Player player = event.getPlayer()
        if ((player.hasPermission("miscellaneous.bypass") || player.isOp()) && !permBypassingPlayers.contains(player.getUniqueId())) {
            permBypassingPlayers.add(player.getUniqueId())
        }

    }
}
Events.subscribe(PlayerQuitEvent.class, EventPriority.HIGH).handler { event ->
    if (Patches.exploitMovementLimitations) {
        Player player = event.getPlayer()
        permBypassingPlayers.remove(player.getUniqueId())
        factionsBypassingPlayers.remove(player.getUniqueId())
    }
}
Events.subscribe(PlayerMoveEvent.class, EventPriority.HIGHEST).filter(EventFilters.<PlayerMoveEvent> ignoreCancelled()).handler { event ->
    if (Patches.exploitMovementLimitations) {
        Location to = event.getTo()
        Location from = event.getFrom()
        if (!(to.getY() >= 280.0)) {
            if (from.getWorld() == to.getWorld()) {
                double distance = from.distanceSquared(to)
                if (distance != 0.0D) {
                    Player player = event.getPlayer()
                    if (player.getGameMode() == GameMode.SURVIVAL) {
                        if (!permBypassingPlayers.contains(player.getUniqueId())) {
                            if (!MovementUtils.isPlayerSameChunk(from, to)) {
                                updateFactionsBypass(player, to)
                            }

                            if (!factionsBypassingPlayers.contains(player.getUniqueId())) {
                                if (distance > 64.0) {
                                    event.setTo(from.setDirection(to.getDirection()))
                                } else if (WorldUtils.isOutsideWorldBorder(to, false)) {
                                    event.setTo(from.setDirection(to.getDirection()))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

static def updateFactionsBypass(@Nonnull Player player, @Nonnull Location to) {
    if (!WorldUtils.isOutsideWorldBorder(to, false) && FactionUtils.isPhaseIgnorePlayer(player, to)) {
        factionsBypassingPlayers.add(player.getUniqueId())
    } else {
        factionsBypassingPlayers.remove(player.getUniqueId())
    }

}

Events.subscribe(CreatureSpawnEvent.class, EventPriority.LOWEST).filter(EventFilters.<CreatureSpawnEvent> ignoreCancelled()).handler { event ->
    if (Patches.exploitSpawnEggLimitations) {
        if (!event.isCancelled()) {
            if (event.getSpawnReason() == CreatureSpawnEvent.SpawnReason.SPAWNER_EGG) {
                Location location = event.getEntity().getLocation()
                Material self = location.getBlock().getType()
                Material selfUp = location.getBlock().getRelative(BlockFace.UP).getType()
                Material selfDown = location.getBlock().getRelative(BlockFace.DOWN).getType()
                if (selfDown != Material.CHEST && self != Material.CHEST && selfUp != Material.CHEST && selfDown != Material.TRAPPED_CHEST && self != Material.TRAPPED_CHEST && selfUp != Material.TRAPPED_CHEST) {
                    if (self.isSolid() || selfUp.isSolid()) {
                        event.setCancelled(true)
                    }

                }
            }
        }
    }
}
Events.subscribe(PlayerInteractEvent.class, EventPriority.HIGHEST).filter(EventFilters.<PlayerInteractEvent> ignoreCancelled()).handler { event ->
    if (Patches.exploitSpawnEggLimitations) {
        if (event.getAction() == Action.RIGHT_CLICK_AIR || event.getAction() == Action.RIGHT_CLICK_BLOCK) {
            ItemStack item = event.getHand() == EquipmentSlot.HAND ? event.getPlayer().getInventory().getItemInMainHand() : event.getPlayer().getInventory().getItemInOffHand()
            if (item != null && item.getType() != Material.AIR) {
                if (item.getType().name().endsWith("_SPAWN_EGG")) {
                    if (item.getDurability() == 50L) {
                        Player player = event.getPlayer()
                        if (!player.hasPermission("miscellaneous.bypass")) {
                            if (!event.hasBlock()) {
                                event.setCancelled(true)
                            } else if (event.getClickedBlock().getLocation().distanceSquared(player.getLocation()) > 25.0) {
                                event.setCancelled(true)
                            }
                        }
                    }
                }
            }
        }
    }
}
//Events.subscribe(PlayerJoinEvent.class, EventPriority.HIGHEST).handler { event ->
//    if (Patches.glitchFactionsOfflineTimer) {
//        Player player = event.getPlayer()
//        if (!player.hasPermission("miscellaneous.bypass")) {
//            if (!FactionUtils.isNonPlayerFactionLandOrOwn(player, player.getLocation())) {
//                long stamp = System.currentTimeMillis() - essentials.getUser(player).getLastLogin()
//                ConsoleCommandSender console = Bukkit.getServer().getConsoleSender()
//                int offlineTimerLength = Patches.glitchFactionsOfflineTimerLengthSeconds
//                boolean deniedLand = false
//                if (Patches.glitchFactionsOfflineTimerTruce && FactionUtils.isRelationToTruce(player, player.getLocation()) && stamp >= TimeUnit.SECONDS.toMillis((long) offlineTimerLength)) {
//                    deniedLand = true
//                }
//
//                if (Patches.glitchFactionsOfflineTimerAlly && FactionUtils.isRelationToAlly(player, player.getLocation()) && stamp >= TimeUnit.SECONDS.toMillis((long) offlineTimerLength)) {
//                    deniedLand = true
//                }
//
//                if (Patches.glitchFactionsOfflineTimerEnemy && FactionUtils.isRelationToEnemy(player, player.getLocation()) && stamp >= TimeUnit.SECONDS.toMillis((long) offlineTimerLength)) {
//                    deniedLand = true
//                }
//
//                if (Patches.glitchFactionsOfflineTimerNeutral && FactionUtils.isRelationToNeutral(player, player.getLocation()) && stamp >= TimeUnit.SECONDS.toMillis((long) offlineTimerLength)) {
//                    deniedLand = true
//                }
//
//                if (deniedLand) {
//                    Bukkit.dispatchCommand(console, "spawn " + player.getName())
//                    Players.msg(player, Patches.glitchFactionsOfflineTimerMsgDeny)
//                    player.playSound(player.getLocation(), Sound.ENTITY_VILLAGER_NO, 5.0F, 1.0F)
//                }
//
//            }
//        }
//    }
//}
Events.subscribe(EntityChangeBlockEvent.class, EventPriority.NORMAL).filter(EventFilters.<EntityChangeBlockEvent> ignoreCancelled()).handler { event ->
    if (Patches.exploitFallingBlockWebLimitations) {
        if (event.getEntity() instanceof FallingBlock) {
            Block block = event.getBlock()
            int y = block.getY() + 1
            Location location = new Location(block.getWorld(), (double) block.getX(), (double) y, (double) block.getZ())
            if (location.getBlock().getType() == Material.COBWEB) {
                location.getBlock().setType(Material.AIR, true)
            }

        }
    }
}
Events.subscribe(EntityExplodeEvent.class, EventPriority.HIGHEST).filter(EventFilters.<EntityExplodeEvent> ignoreCancelled()).handler { event ->
    if (event.getEntity() != null && !(event.getYield() <= 0.0F)) {
        if (event.getEntity().getType() == EntityType.PRIMED_TNT) {
            if (Patches.exploitWaterLoggedExplosionCorrection) {
                Block block = event.getLocation().getBlock()

                for (int x = -Patches.exploitWaterLoggedExplosionCorrectionRadius; x <= Patches.exploitWaterLoggedExplosionCorrectionRadius; ++x) {
                    for (int y = -Patches.exploitWaterLoggedExplosionCorrectionRadius; y <= Patches.exploitWaterLoggedExplosionCorrectionRadius; ++y) {
                        for (int z = -Patches.exploitWaterLoggedExplosionCorrectionRadius; z <= Patches.exploitWaterLoggedExplosionCorrectionRadius; ++z) {
                            if (y > -64 && y < 320) {
                                Location loc = block.getLocation()
                                Block b = loc.getWorld().getBlockAt(loc.clone().add((double) x, (double) y, (double) z))
                                double distanceY = loc.getY() > (double) b.getY() ? loc.getY() - (double) b.getY() : (double) b.getY() - loc.getY()
                                if (!(distanceY > (double) Patches.exploitWaterLoggedExplosionCorrectionRadius) && WorldUtils.isWaterlogged(b)) {
                                    WorldUtils.setWaterlogged(b, false)
                                }
                            }
                        }
                    }
                }

            }
        }
    }
}
Events.subscribe(ItemSpawnEvent.class, EventPriority.NORMAL).filter(EventFilters.<ItemSpawnEvent> ignoreCancelled()).handler { event ->
    if (event.getEntity() != null) {
        ItemStack item = event.getEntity().getItemStack()
        if (item != null && item.getType() != Material.AIR) {
            if (item.getType() == Material.SAND || item.getType() == Material.RED_SAND || item.getType() == Material.GRAVEL) {
                if (Patches.exploitFallingBlockNonFullBlockCorrection) {
                    Block block = event.getLocation().getBlock()
                    if (block != null && !block.isLiquid()) {
                        if (!Patches.exploitFallingBlockNonFullBlockCorrectionIgnoreNonWaterLogged || WorldUtils.isWaterlogged(block)) {
                            if (block.getBlockData() instanceof Slab || block.getBlockData() instanceof PointedDripstone || block.getBlockData() instanceof SeaPickle || block.getBlockData() instanceof Chest || block.getBlockData() instanceof EnderChest || block.getBlockData() instanceof Sign || block.getBlockData() instanceof WallSign || block.getBlockData() instanceof Bed || block.getBlockData() instanceof Lantern || block.getBlockData() instanceof Campfire || block.getBlockData() instanceof TrapDoor || block.getBlockData() instanceof Skull || block.getBlockData() instanceof AmethystCluster || block.getBlockData() instanceof Farmland || block.getBlockData() instanceof Waterlogged || block.getType() == Material.CACTUS || block.getType() == Material.ENCHANTING_TABLE || block.getType() == Material.LILY_PAD || block.getType() == Material.STONECUTTER || block.getType() == Material.HONEY_BLOCK) {
                                event.setCancelled(true)
                                Block blockUp = block.getRelative(BlockFace.UP)
                                blockUp.setType(event.getEntity().getItemStack().getType())
                            }

                        }
                    }
                }
            }
        }
    }
}
Events.subscribe(InventoryOpenEvent.class, EventPriority.HIGHEST).filter(EventFilters.<InventoryOpenEvent> ignoreCancelled()).handler { event ->
    if (event.getInventory() != null && event.getInventory().getType() == InventoryType.ANVIL) {
        if (Patches.exploitLimitAnvilActions) {
            Player player = (Player) event.getPlayer()
            if (!anvilUsagePlayers.contains(player.getUniqueId())) {
                anvilUsagePlayers.add(player.getUniqueId())
            }

        }
    }
}
Events.subscribe(InventoryCloseEvent.class, EventPriority.HIGHEST).handler { event ->
    if (event.getInventory() != null && event.getInventory().getType() == InventoryType.ANVIL) {
        if (Patches.exploitLimitAnvilActions) {
            Player player = (Player) event.getPlayer()
            if (anvilUsagePlayers.contains(player.getUniqueId())) {
                anvilUsagePlayers.remove(player.getUniqueId())
            }

        }
    }
}
Events.subscribe(PlayerDropItemEvent.class, EventPriority.HIGH).filter(EventFilters.<PlayerDropItemEvent> ignoreCancelled()).handler { event ->
    if (event.getItemDrop() != null) {
        if (Patches.exploitLimitAnvilActions) {
            Player player = event.getPlayer()
            if (anvilUsagePlayers.contains(player.getUniqueId())) {
                event.setCancelled(true)
                player.updateInventory()
                Players.msg(player, Patches.exploitLimitAnvilActionsMsgDropItemDeny)
                player.playSound(player.getLocation(), Sound.ENTITY_VILLAGER_NO, 5.0F, 1.0F)
            }

        }
    }
}
Events.subscribe(EntityPickupItemEvent.class, EventPriority.HIGH).filter(EventFilters.<EntityPickupItemEvent> ignoreCancelled()).handler { event ->
    if (event.getEntity() != null && event.getEntityType() == EntityType.PLAYER) {
        if (Patches.exploitLimitAnvilActions) {
            Player player = (Player) event.getEntity()
            if (anvilUsagePlayers.contains(player.getUniqueId())) {
                event.setCancelled(true)
            }

        }
    }
}
Events.subscribe(InventoryClickEvent.class, EventPriority.HIGH).filter(EventFilters.<InventoryClickEvent> ignoreCancelled()).handler { event ->
    if (event.getWhoClicked() instanceof Player) {
        if (event.getInventory().getHolder() == null) {
            if (event.getCurrentItem() != null) {
                if (event.getClick() == ClickType.NUMBER_KEY || event.getClick() == ClickType.SHIFT_RIGHT || event.getClick() == ClickType.SHIFT_LEFT) {
                    if (Patches.exploitLimitAnvilActions) {
                        Inventory inventory = event.getClickedInventory()
                        if (inventory != null) {
                            Player player = (Player) event.getWhoClicked()
                            if (anvilUsagePlayers.contains(player.getUniqueId())) {
                                ClickType clickType = event.getClick()
                                if (inventory.getType() == InventoryType.ANVIL && clickType == ClickType.NUMBER_KEY && event.getAction() == InventoryAction.HOTBAR_SWAP) {
                                    event.setCancelled(true)
                                    event.setResult(Event.Result.DENY)
                                    Players.msg(player, Patches.exploitLimitAnvilActionsMsgNumberClickDeny)
                                    player.playSound(player.getLocation(), Sound.ENTITY_VILLAGER_NO, 5.0F, 1.0F)
                                } else if (inventory.getType() == InventoryType.PLAYER && clickType == ClickType.SHIFT_RIGHT || clickType == ClickType.SHIFT_LEFT) {
                                    event.setCancelled(true)
                                    event.setResult(Event.Result.DENY)
                                    Players.msg(player, Patches.exploitLimitAnvilActionsMsgShiftClickDeny)
                                    player.playSound(player.getLocation(), Sound.ENTITY_VILLAGER_NO, 5.0F, 1.0F)
                                }

                            }
                        }
                    }
                }
            }
        }
    }
}
Events.subscribe(EntityExplodeEvent.class, EventPriority.NORMAL).filter(EventFilters.<EntityExplodeEvent> ignoreCancelled()).handler { event ->
    if (event.getEntityType() == EntityType.PRIMED_TNT || event.getEntityType() == EntityType.CREEPER) {
        if (Patches.exploitExplosiveAltitudeLimitations) {
            event.blockList().removeIf((block) -> {
                return isInvalidExplosionAltitude(block)
            })
        }
    }
}

static boolean isInvalidExplosionAltitude(@Nonnull Block block) {
    World world = block.getWorld()
    Location location = block.getLocation()
    if (location.getBlockY() > world.getMaxHeight()) {
        return true
    } else {
        return location.getBlockY() < world.getMinHeight()
    }
}
